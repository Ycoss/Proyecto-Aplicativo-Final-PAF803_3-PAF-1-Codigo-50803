<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guion de Presentación: Juego de Asteroides</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #212529;
        }
        .container {
            width: 85%;
            margin: 20px auto;
            overflow: hidden;
            padding: 25px;
            background-color: #ffffff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: #ffffff;
            padding: 25px;
            text-align: center;
            border-bottom: #0056b3 5px solid;
        }
        header h1 {
            margin: 0;
            font-size: 2.8em;
            font-weight: bold;
        }
        header p {
            margin: 8px 0 0;
            font-size: 1.1em;
        }
        nav {
            background: #343a40;
            color: #fff;
            padding: 12px 0;
            text-align: center;
            border-radius: 0 0 8px 8px;
        }
        nav ul {
            padding: 0;
            list-style: none;
            margin: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav a {
            color: #f8f9fa;
            text-decoration: none;
            font-size: 1.25em;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        nav a:hover {
            color: #00bcd4;
        }
        section {
            padding: 25px;
            margin-top: 25px;
            border-bottom: 2px #e9ecef dotted;
        }
        section:last-of-type {
            border-bottom: none;
        }
        h2 {
            color: #0056b3;
            border-bottom: 3px solid #007bff;
            padding-bottom: 8px;
            font-size: 2em;
            margin-bottom: 20px;
        }
        h3 {
            color: #343a40;
            margin-top: 25px;
            font-size: 1.6em;
            margin-bottom: 10px;
        }
        .guion-item {
            background-color: #e9ecef;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 7px solid #007bff;
            border-radius: 5px;
        }
        .guion-item strong, .highlight {
            color: #0056b3;
            font-weight: bold;
        }
        .keyword {
            color: #d9534f; /* Rojo suave para palabras clave */
            font-weight: bold;
        }
        .emphasis {
            color: #5cb85c; /* Verde para énfasis */
            font-style: italic;
            font-weight: bold;
        }
        footer {
            text-align: center;
            padding: 25px;
            background-color: #343a40;
            color: #f8f9fa;
            margin-top: 35px;
        }
        ul li strong {
            color: #28a745; /* Verde para puntos de aprendizaje */
        }
    </style>
</head>
<body>
    <header>
        <h1>Juego de Asteroides: Diseño e Implementación Orientada a Objetos en Java</h1>
        <p>Equipo PAF803_3:</p>
        <p>Yadi Alejandro Landa Cossio - 545958</p>
        <p>Santiago Elin Mandujano Aguilar - 564640</p>
        <p>Armando Díaz Castillo - 00562897</p>
        <p>Jorge Carlos Zapata Villanueva - 543478</p>
    </header>

    <nav>
        <ul>
            <li><a href="#presentador1">Presentador 1</a></li>
            <li><a href="#presentador2">Presentador 2</a></li>
            <li><a href="#presentador3">Presentador 3</a></li>
            <li><a href="#presentador4">Presentador 4</a></li>
        </ul>
    </nav>

    <div class="container">
        <section id="presentador1">
            <h2>Presentador 1</h2>
            <div class="guion-item">
                <h3>Diapositiva 1: Portada</h3>
                <p><strong>Guion:</strong></p>
                <p>"Buenos días/tardes a todos. Somos el equipo <span class="highlight">PAF803_3</span>, y nuestros nombres son Yadi Alejandro Landa Cossio, Santiago Elin Mandujano Aguilar, Armando Díaz Castillo y Jorge Carlos Zapata Villanueva."</p>
                <p>"Hoy, tenemos el placer de presentarles nuestro <span class="keyword">Proyecto Aplicativo Final</span>, que consiste en el desarrollo de un 'Juego de Asteroides' utilizando <span class="highlight">Java</span> y aplicando una perspectiva de <span class="emphasis">programación orientada a objetos</span>."</p>
            </div>
            <div class="guion-item">
                <h3>Diapositiva 2: Introducción y Objetivos del Proyecto</h3>
                <p><strong>Guion:</strong></p>
                <p>"Para comenzar, nuestro proyecto se centró en recrear el icónico videojuego de disparos espaciales <span class="keyword">'Asteroides'</span>. En este juego, el jugador toma el control de una nave espacial y su misión es simple pero desafiante: <span class="emphasis">destruir la mayor cantidad posible de asteroides y naves enemigas</span> que aparecen progresivamente, todo mientras evita colisionar con ellos. El objetivo final es <span class="highlight">sobrevivir el mayor tiempo posible</span> para acumular la puntuación más alta."</p>
                <p>"En cuanto a los objetivos que nos planteamos para este desarrollo, el principal fue <span class="keyword">aplicar de manera práctica</span> los conocimientos adquiridos en <span class="highlight">programación orientada a objetos</span>. Esto incluyó el <span class="emphasis">diseño cuidadoso de clases</span>, el uso de <span class="emphasis">herencia</span> para compartir comportamientos, y el <span class="emphasis">polimorfismo</span> para manejar diferentes tipos de objetos de forma unificada. Además, nos enfocamos en implementar un <span class="highlight">sistema robusto para gestionar los diferentes estados del juego</span> – como el menú, la partida en sí, y la tabla de puntuaciones – así como en el manejo eficiente de los <span class="keyword">recursos gráficos y de sonido</span>, y por supuesto, en la implementación de toda la lógica fundamental que hace funcionar al videojuego. Esto abarcó desde los <span class="highlight">controles del jugador</span>, a los que dimos una actualización moderna permitiendo el uso tanto de las teclas tradicionales como de combinaciones tipo <span class="keyword">WASD</span> y el disparo mediante <span class="keyword">clic del ratón</span>, hasta la <span class="emphasis">detección de colisiones precisa</span> (distinguiendo ahora entre los láseres del jugador y los <span class="highlight">láseres enemigos que sí causan daño</span>) y los <span class="highlight">comportamientos programados</span> para los enemigos. Una parte importante de nuestro trabajo fue <span class="emphasis">mejorar la experiencia del usuario</span> añadiendo características como <span class="keyword">niveles de dificultad</span> (Fácil, Medio, Extremo) que no solo ajustan la velocidad de los OVNIs, sino que también <span class="highlight">modifican visualmente la nave del jugador y sus láseres con colores distintivos</span> (azul para Fácil, verde para Medio y rojo para Extremo), una <span class="highlight">pantalla dedicada a mostrar los controles</span> del juego accesible desde el menú principal, y una <span class="keyword">funcionalidad de pausa</span> que permite al jugador detener la acción momentáneamente y reanudarla cuando lo desee. Para lograrlo, nos basamos en el material de referencia proporcionado, adaptándolo y mejorándolo significativamente."</p>
            </div>
            <div class="guion-item">
                <h3>Diapositiva 3: Arquitectura General del Juego</h3>
                <p><strong>Guion:</strong></p>
                <p>"Para asegurar que nuestro código fuera <span class="highlight">organizado, modular y fácil de mantener</span>, definimos una <span class="keyword">arquitectura basada en paquetes</span>. Como pueden ver, tenemos el paquete <span class="emphasis">main</span>, que contiene la clase <span class="highlight">Window</span>, el corazón de nuestra aplicación, responsable de inicializar el juego y gestionar el bucle principal. El paquete <span class="emphasis">gameObjects</span> es fundamental, ya que agrupa todas las <span class="keyword">entidades interactivas</span> de nuestro universo: la nave del jugador, los asteroides, los OVNIs, los láseres y los power-ups."</p>
                <p>"Un aspecto clave de nuestra arquitectura es la implementación del <span class="keyword">patrón de diseño 'State'</span>, gestionado a través del paquete <span class="emphasis">states</span>. Este patrón nos permite <span class="highlight">encapsular los diferentes comportamientos y vistas del juego</span> – como la pantalla de carga, el menú principal (que ahora incluye acceso a una pantalla de <span class="keyword">Controles</span> y selección de <span class="keyword">Dificultad</span>), la partida en sí (con su propia lógica de <span class="keyword">Pausa</span>), y la visualización de las puntuaciones más altas – en <span class="emphasis">objetos de estado individuales</span>, facilitando las transiciones entre ellos."</p>
                <p>"Los paquetes restantes como <span class="highlight">graphics, input, io, ui y math</span> proveen clases de utilidad esenciales: <span class="keyword">graphics</span> para todo lo relacionado con la carga y renderizado de imágenes y animaciones, incluyendo las <span class="emphasis">texturas dinámicas de la nave y láseres</span> que cambian según la dificultad; <span class="keyword">input</span> para capturar las acciones del teclado (WASD, flechas, y la tecla de <span class="highlight">Pausa como la barra espaciadora</span>) y los eventos del ratón; <span class="keyword">io</span> para la persistencia de las puntuaciones; <span class="keyword">ui</span> para los elementos de la interfaz como botones, incluyendo el nuevo botón de 'Controles'; y <span class="keyword">math</span> para cálculos vectoriales. La clase <span class="emphasis">Constants</span> en `gameObjects` también es vital, ya que define no solo valores numéricos sino que también es donde se gestiona la lógica para <span class="keyword">establecer la dificultad</span> y los <span class="highlight">cambios de apariencia asociados</span>. Esta estructura, fuertemente apoyada en la <span class="highlight">programación orientada a objetos</span>, nos permitió desarrollar un sistema <span class="emphasis">robusto y escalable</span>."</p>
            </div>
        </section>

        <section id="presentador2">
            <h2>Presentador 2</h2>
            <div class="guion-item">
                <h3>Diapositiva 4: Clases Creadas por el Programador (Parte 1 - Entidades del Juego y Estados)</h3>
                <p><strong>Guion:</strong></p>
                <p>"Profundizando en las clases que desarrollamos, es importante reiterar que nos enfocaremos <span class="keyword">exclusivamente en aquellas creadas por nuestro equipo</span>, omitiendo las clases predeterminadas de la API de Java."</p>
                <p>"Comenzando con el paquete <span class="highlight">gameObjects</span>, que define todas las entidades interactivas de nuestro juego:"</p>
                <p>"Tenemos <span class="emphasis">GameObject</span>, nuestra <span class="keyword">clase base abstracta</span>. Esta clase encapsula las propiedades fundamentales que todo objeto en nuestro juego debe tener, como una <span class="highlight">posición</span> en el espacio bidimensional y una <span class="highlight">textura gráfica</span>."</p>
                <p>"De <span class="emphasis">GameObject</span> hereda <span class="emphasis">MovingObject</span>, otra <span class="keyword">clase abstracta</span>, que añade la lógica y los atributos necesarios para el <span class="highlight">movimiento</span>, como velocidad, ángulo de rotación, y la capacidad de <span class="highlight">detectar colisiones</span>, incluyendo la lógica para diferenciar si un láser es del jugador o de un enemigo."</p>
                <p>"Luego, tenemos las <span class="keyword">clases concretas</span> que heredan de <span class="emphasis">MovingObject</span>: <span class="highlight">Player</span> (la nave que controla el usuario, cuya apariencia <span class="emphasis">cambia con la dificultad</span> y dispara láseres marcados como no enemigos), <span class="highlight">Meteor</span> (los asteroides que se dividen), <span class="highlight">Ufo</span> (las naves enemigas que ahora disparan láseres marcados como enemigos y que sí dañan al jugador), <span class="highlight">Laser</span> (los proyectiles, que también <span class="emphasis">cambian de color según la dificultad</span> y ahora llevan una bandera para identificar si son enemigos) y <span class="highlight">PowerUp</span> (los ítems que otorgan ventajas). Cada una de estas clases <span class="emphasis">especializa el comportamiento heredado</span>, por ejemplo, <span class="keyword">Player</span> responde a las entradas del teclado (utilizando las teclas de dirección o <span class="highlight">WASD</span>) y del ratón para el <span class="highlight">disparo</span>, mientras que <span class="keyword">Meteor</span> tiene la lógica para <span class="emphasis">fragmentarse</span> al ser destruido."</p>
                <p>"Paralelamente, en el paquete <span class="highlight">states</span>, gestionamos las diferentes fases del juego:"</p>
                <p>"<span class="emphasis">State</span> es nuestra <span class="keyword">clase base abstracta</span> (o interfaz, según la implementación final) que define el <span class="highlight">contrato para todos los estados</span>, principalmente a través de los métodos <span class="emphasis">update()</span> para la lógica y <span class="emphasis">draw()</span> para el renderizado."</p>
                <p>"Las clases <span class="highlight">GameState, MenuState, ScoreState, LoadingState, ControlsState y PauseMenuState</span> implementan (o heredan de) <span class="emphasis">State</span>, cada una manejando la lógica y la presentación visual de su respectiva pantalla: la partida (que ahora puede ser <span class="keyword">pausada</span>), el menú (con <span class="keyword">nuevas opciones</span> como 'Controles'), la tabla de puntuaciones, la pantalla de carga inicial, la pantalla de visualización de controles y el menú de pausa."</p>
                <p>"Esta <span class="keyword">jerarquía de clases</span> y el uso de la <span class="highlight">herencia</span> no solo nos permitieron <span class="emphasis">reutilizar una gran cantidad de código</span>, sino también aplicar <span class="keyword">polimorfismo</span>, por ejemplo, al tener una lista de <span class="highlight">MovingObject</span> y llamar a sus métodos <span class="emphasis">update</span> y <span class="emphasis">draw</span> sabiendo que se ejecutará la versión específica de cada objeto."</p>
            </div>
            <div class="guion-item">
                <h3>Diapositiva 5: Clases Creadas por el Programador (Parte 2 - Soporte y Utilidades)</h3>
                <p><strong>Guion:</strong></p>
                <p>"Para complementar las entidades y estados del juego, desarrollamos una serie de <span class="keyword">clases de soporte y utilidad</span>, organizadas en sus respectivos paquetes:"</p>
                <p>"En el paquete <span class="highlight">graphics</span>, la clase <span class="emphasis">Assets</span> es crucial, ya que <span class="keyword">centraliza la carga de todos los recursos visuales y auditivos</span>, como imágenes para los sprites (incluyendo las <span class="highlight">variantes de color para la nave y los láseres</span> según la dificultad), fuentes de texto y clips de sonido. <span class="emphasis">Loader</span> contiene los métodos estáticos que <span class="highlight">Assets</span> utiliza para realizar esta carga. <span class="emphasis">Animation</span> nos permite crear <span class="keyword">efectos visuales dinámicos</span>. <span class="emphasis">Text</span> es una utilidad para dibujar texto en pantalla. Y <span class="emphasis">Sound</span> maneja la <span class="highlight">reproducción de los efectos de sonido y la música de fondo</span>, que ahora <span class="keyword">puede pausarse y reanudarse</span> junto con el juego."</p>
                <p>"La interacción del usuario se gestiona a través del paquete <span class="highlight">input</span>. <span class="emphasis">KeyBoard</span> implementa <span class="highlight">KeyListener</span> para capturar pulsaciones de teclas, incluyendo <span class="keyword">WASD</span>, flechas, y la <span class="emphasis">barra espaciadora para la función de Pausa</span>. <span class="emphasis">MouseInput</span> extiende <span class="highlight">MouseAdapter</span> para el disparo con clic y la interacción con la interfaz, como en el <span class="keyword">botón 'Controles'</span> del menú."</p>
                <p>"Los elementos de la interfaz de usuario, como los <span class="highlight">botones</span>, se definen en el paquete <span class="emphasis">ui</span>. La clase <span class="keyword">Button</span> representa un botón interactivo, y la interfaz <span class="keyword">Action</span> define su comportamiento. Esto fue clave para añadir el <span class="highlight">botón 'Controles'</span> en `MenuState` que lleva a la nueva pantalla `ControlsState`, y los botones en `PauseMenuState`."</p>
                <p>"Para la <span class="keyword">persistencia de las puntuaciones más altas</span>, utilizamos el paquete <span class="emphasis">io</span>. <span class="highlight">JSONParser</span> y <span class="emphasis">ScoreData</span> gestionan la lectura y escritura de puntuaciones."</p>
                <p>"En el paquete <span class="highlight">math</span>, <span class="emphasis">Vector2D</span> es fundamental. <span class="highlight">Window</span> en <span class="emphasis">main</span> es el punto de entrada. La clase <span class="emphasis">Constants</span> en <span class="highlight">gameObjects</span> es donde se definen constantes y, crucialmente, donde el método <code class="keyword">setDifficulty()</code> ahora <span class="highlight">actualiza las variables que determinan las texturas actuales de la nave y el láser</span>, permitiendo el cambio visual dinámico (azul, verde, rojo) que implementamos."</p>
            </div>
        </section>

        <section id="presentador3">
            <h2>Presentador 3</h2>
            <div class="guion-item">
                <h3>Diapositiva 6: Diagrama UML - Herencia e Implementaciones</h3>
                <p><strong>Guion:</strong></p>
                <p>"Este <span class="keyword">diagrama UML</span> representa visualmente la <span class="highlight">estructura de clases</span> de nuestro proyecto, destacando las relaciones de <span class="emphasis">herencia</span> y las <span class="emphasis">implementaciones de interfaces</span>, que son fundamentales desde una perspectiva orientada a objetos."</p>
                <p>"Observen las relaciones de <span class="keyword">herencia</span>, indicadas por las flechas con punta triangular hueca. <span class="highlight">GameObject</span> actúa como la clase base para <span class="highlight">MovingObject</span>. A su vez, <span class="highlight">MovingObject</span> es la superclase de varias clases derivadas como <span class="emphasis">Player, Meteor, Ufo, Laser y PowerUp</span>. Cada una de estas clases derivadas <span class="keyword">hereda atributos y métodos comunes</span> de <span class="highlight">MovingObject</span> (como la capacidad de moverse y colisionar) pero los <span class="emphasis">especializa o añade nueva funcionalidad</span>. Lo mismo ocurre con la jerarquía de <span class="highlight">State</span>, donde <span class="emphasis">GameState, MenuState, ControlsState, PauseMenuState</span>, etc., heredan de una clase <span class="keyword">State</span> base."</p>
                <p>"En cuanto a las <span class="keyword">implementaciones de interfaces</span>, representadas por flechas discontinuas con punta triangular hueca, vemos que nuestra clase <span class="highlight">KeyBoard</span> implementa la interfaz <span class="emphasis">KeyListener</span> de Java, y <span class="highlight">MouseInput</span> implementa las interfaces correspondientes (<span class="emphasis">MouseListener/MouseAdapter</span>) para los eventos del ratón, lo que les permite responder a las acciones del usuario. <span class="highlight">Window</span>, la clase principal, implementa <span class="emphasis">Runnable</span>, permitiendo que el bucle del juego se ejecute en un hilo separado. La interfaz <span class="highlight">Action</span>, definida por nosotros, es implementada por <span class="keyword">clases anónimas</span> dentro de <span class="emphasis">MenuState, ControlsState, PauseMenuState</span> y <span class="emphasis">GameState</span> para definir las acciones de los botones y los power-ups de manera concisa y específica."</p>
                <p>"Este diseño nos ha permitido construir un sistema donde las <span class="highlight">responsabilidades están bien definidas</span>, se promueve la <span class="keyword">reutilización de código</span> y se facilita la <span class="emphasis">extensión futura</span> del juego."</p>
            </div>
             <div class="guion-item">
                <h3>Diapositiva 7: Atributos y Métodos Relevantes (Clase Player y herencia de MovingObject)</h3>
                <p><strong>Guion:</strong></p>
                <p>"Para ejemplificar cómo estructuramos nuestras clases y aplicamos la <span class="keyword">herencia</span>, observemos la clase <span class="highlight">Player</span>. A la izquierda, pueden ver algunos de sus <span class="emphasis">atributos clave</span>, como <code class="keyword">heading</code> que es un <span class="highlight">Vector2D</span> para la dirección, <code class="keyword">acceleration</code> también un <span class="highlight">Vector2D</span>, <code class="keyword">fireRate</code> un <span class="highlight">long</span> para controlar la cadencia de disparo, y booleanos como <code class="keyword">spawning</code> o <code class="keyword">shieldOn</code> para controlar estados específicos del jugador. Noten que estos atributos son generalmente <span class="emphasis">privados</span>, respetando el <span class="highlight">encapsulamiento</span>."</p>
                <p>"A la derecha, destacamos algunos <span class="keyword">métodos importantes</span>. Crucialmente, los métodos <code class="highlight">update(float dt)</code> y <code class="highlight">draw(Graphics g)</code> son heredados de su superclase, <span class="emphasis">MovingObject</span>. Sin embargo, en <span class="highlight">Player</span>, estos métodos son <span class="keyword">sobrescritos</span> para implementar la <span class="emphasis">lógica específica</span> de cómo el jugador se actualiza en cada frame – procesando la entrada del teclado (sea <span class="highlight">flechas o WASD</span>) y del <span class="highlight">ratón</span> para moverse, rotar y disparar (creando láseres que se identifican como no enemigos), controlando el disparo, gestionando power-ups – y cómo se dibuja en pantalla, incluyendo la correcta orientación de la nave y efectos visuales como la estela de propulsión o el escudo. <span class="keyword">Es importante destacar que el método draw ahora selecciona la textura de la nave (azul, verde o roja) basándose en la dificultad actual</span>, gracias a las variables que se actualizan en `Assets`."</p>
                <p>"El método <code class="highlight">Destroy()</code> también es heredado y <span class="keyword">sobrescrito</span>. Mientras <span class="emphasis">MovingObject</span> define una forma genérica de ser destruido, <span class="highlight">Player</span> añade la lógica de <span class="keyword">perder una vida</span>, reproducir un sonido específico y gestionar el proceso de <span class="emphasis">'respawn'</span> o reaparición."</p>
                <p>"Además, <span class="highlight">Player</span> tiene <span class="keyword">métodos propios</span> como podría ser uno para <code class="emphasis">shootLaser()</code>, que ahora también instancia láseres con la <span class="highlight">textura de color apropiada</span> y los marca correctamente como no enemigos. Otros métodos útiles como <code class="highlight">collidesWith()</code> (que ahora, en <span class="emphasis">MovingObject</span>, gestiona las colisiones Player-Laser diferenciando si el láser es enemigo) y <code class="highlight">getCenter()</code> son heredados directamente de <span class="emphasis">MovingObject</span> y utilizados por el jugador. Esta combinación de <span class="keyword">herencia, sobrescritura y métodos propios</span> es lo que le da al jugador su comportamiento único dentro del juego."</p>
            </div>
        </section>

        <section id="presentador4">
            <h2>Presentador 4</h2>
            <div class="guion-item">
                <h3>Diapositiva 8: Atributos y Métodos Relevantes (Clase GameState y uso polimórfico de MovingObject)</h3>
                <p><strong>Guion:</strong></p>
                <p>"Otra clase central para entender la aplicación de la POO en nuestro juego es <span class="highlight">GameState</span>. Esta clase es responsable de <span class="keyword">toda la lógica que ocurre durante una partida</span>. Como pueden ver, entre sus atributos principales se encuentra una referencia al objeto <span class="emphasis">player</span> y, muy importante, una <code class="highlight">ArrayList&lt;MovingObject&gt;</code> llamada <code class="keyword">movingObjects</code>. Esta lista es la que contiene todos los <span class="emphasis">objetos dinámicos</span> en pantalla: los asteroides, los OVNIs enemigos, los láseres disparados (que ahora <span class="highlight">varían de color</span>) y los power-ups. También gestiona la <span class="keyword">entrada para la pausa</span>, llevando al `PauseMenuState` cuando se presiona la barra espaciadora."</p>
                <p>"Los métodos <code class="highlight">update(float dt)</code> y <code class="highlight">draw(Graphics g)</code> de <span class="emphasis">GameState</span> son donde el poder del <span class="keyword">polimorfismo</span> brilla. Dentro del método <code class="highlight">update</code> de <span class="emphasis">GameState</span>, (cuando el juego no está pausado), recorremos la lista <code class="keyword">movingObjects</code> y para cada <span class="highlight">MovingObject</span> en ella, simplemente llamamos a su método <code class="emphasis">mo.update(dt)</code>. Gracias al <span class="keyword">polimorfismo</span>, Java sabe exactamente qué versión del método <code class="highlight">update</code> ejecutar: si el objeto <code class="keyword">mo</code> es un <span class="highlight">Meteor</span>, se ejecutará <code class="emphasis">Meteor.update()</code>; si es un <span class="highlight">Ufo</span>, se ejecutará <code class="emphasis">Ufo.update()</code>, y así sucesivamente. Lo mismo ocurre en el método <code class="highlight">draw</code> con <code class="emphasis">mo.draw(g)</code>."</p>
                <p>"Esta capacidad de tratar objetos de <span class="keyword">diferentes clases</span> (todas derivadas de <span class="highlight">MovingObject</span>) de una <span class="emphasis">manera uniforme</span>, pero obteniendo su <span class="keyword">comportamiento específico</span>, es una de las grandes ventajas de la programación orientada a objetos. <span class="highlight">Simplifica enormemente el código</span> de <span class="emphasis">GameState</span>, ya que no necesita saber el tipo exacto de cada objeto para actualizarlo o dibujarlo correctamente, demostrando una aplicación <span class="keyword">práctica y eficiente</span> del <span class="highlight">polimorfismo</span>."</p>
            </div>
            <div class="guion-item">
                <h3>Diapositiva 9: Demostración del Funcionamiento</h3>
                <p><strong>Guion (narrar mientras se muestra el video/GIFs):</strong></p>
                <p>"Ahora, para que puedan apreciar mejor el resultado de nuestro trabajo, les mostraremos una <span class="keyword">breve demostración</span> del juego en acción."</p>
                <p>"(Mientras se reproduce el video/secuencia): Comenzamos en el <span class="highlight">menú principal</span>. Aquí pueden ver las opciones para <span class="emphasis">iniciar una nueva partida, ver las puntuaciones, seleccionar la dificultad y consultar los controles</span>. Primero, echemos un vistazo rápido a la <span class="keyword">pantalla de Controles</span>. (Mostrar pantalla de controles). Como ven, detalla todas las acciones y sus teclas asociadas. Volviendo al menú, seleccionaremos una dificultad, por ejemplo, <span class="highlight">'Medio'</span>. Al iniciar, aparece nuestra nave, que ahora es de <span class="keyword">color verde</span>, al igual que nuestros láseres. Si eligiéramos 'Fácil', serían azules, y 'Extremo', rojos. Podemos <span class="emphasis">rotarla y moverla</span> con <span class="keyword">WASD o las flechas</span>, y <span class="emphasis">disparar</span> con la <span class="keyword">tecla 'P' o el clic izquierdo</span>. El objetivo: <span class="highlight">destruir asteroides</span>, que se <span class="emphasis">dividen</span>. También aparecen <span class="highlight">OVNIs enemigos</span>, ¡cuidado con sus láseres, ahora sí nos hacen daño! Ahora, si presionamos la <span class="keyword">barra espaciadora</span>, el juego entra en <span class="highlight">Pausa</span>. (Mostrar menú de pausa). Desde aquí podemos <span class="emphasis">reanudar, reiniciar la partida o volver al menú principal</span>. Reanudemos. También pueden aparecer <span class="keyword">power-ups</span>, como el <span class="emphasis">escudo</span>. Si nos quedamos sin vidas, veremos la pantalla de <span class="highlight">'Game Over'</span>, y nuestra puntuación se registrará."</p>
            </div>
            <div class="guion-item">
                <h3>Diapositiva 10: Nuevos Aprendizajes y Conclusiones</h3>
                <p><strong>Guion (Nuevos Aprendizajes - puede ser leído por el presentador 4, o cada miembro puede decir su parte asignada previamente):</strong></p>
                <p>"A lo largo de este proyecto, cada miembro del equipo tuvo <span class="highlight">aprendizajes significativos</span>. Por ejemplo:"</p>
                <ul>
                    <li><strong>"La aplicación práctica del patrón de diseño 'State' fue fundamental.</strong> Entender cómo encapsular la lógica de cada pantalla del juego (incluyendo los nuevos estados como <span class="keyword">ControlsState</span> y <span class="keyword">PauseMenuState</span>) en clases separadas y gestionar las transiciones fue clave."</li>
                    <li><strong>"Destacamos la importancia de comprender y utilizar correctamente el 'delta time'</strong> (...) la <span class="keyword">gestión de la pausa</span> y la reanudación correcta de la música y los temporizadores también fue un aprendizaje importante aquí."</li>
                    <li><strong>"Fue muy valioso aprender sobre las técnicas de carga y gestión de los diversos recursos</strong> (...), incluyendo la implementación de <span class="emphasis">texturas dinámicas</span> para la nave y láseres según la dificultad, y cómo centralizar esta gestión. Además, implementar <span class="emphasis">opciones de control adicionales como WASD y el disparo con clic del ratón</span>, junto con una <span class="keyword">pantalla de controles clara</span>, nos enseñó sobre la importancia de la <span class="highlight">experiencia del usuario</span>."</li>
                    <li><strong>"La implementación de la detección de colisiones</strong> (afinando detalles como distinguir entre láseres amigos y enemigos para que el jugador reciba daño correctamente), y la aplicación de la <span class="emphasis">física básica para el movimiento de los objetos</span> (...) fueron conceptos muy interesantes de llevar a la práctica."</li>
                    <li><strong>"En general, este proyecto nos brindó una excelente oportunidad para aplicar de manera concreta los principios de la Programación Orientada a Objetos,</strong> como la <span class="keyword">herencia</span> (...), el <span class="keyword">polimorfismo</span> (...), y el <span class="keyword">encapsulamiento</span> (...). La implementación de <span class="highlight">nuevas funcionalidades</span> como los diferentes modos de dificultad con feedback visual, la pantalla de controles y el sistema de pausa, nos obligó a pensar cuidadosamente sobre cómo integrar estas características de manera cohesiva en nuestra arquitectura orientada a objetos."</li>
                </ul>
                <p><strong>Guion (Conclusiones Finales - leídas por Presentador 4):</strong></p>
                <p>"En <span class="keyword">conclusión</span>, el desarrollo de este Juego de Asteroides ha sido una <span class="highlight">experiencia sumamente valiosa</span> que nos ha permitido <span class="emphasis">consolidar y profundizar</span> nuestros conocimientos en <span class="keyword">programación orientada a objetos</span> y en los <span class="highlight">fundamentos del desarrollo de videojuegos</span>, incluyendo la <span class="keyword">mejora iterativa</span> de funcionalidades para el usuario final."</p>
                <p>"A lo largo del proyecto, enfrentamos <span class="emphasis">diversos desafíos</span>, desde la sincronización de eventos de entrada hasta la correcta estructuración del código para las <span class="highlight">nuevas características implementadas</span>, pero gracias al <span class="keyword">trabajo en equipo</span> y la <span class="keyword">perseverancia</span>, logramos superarlos y entregar un <span class="emphasis">producto funcional y mejorado</span> que cumple con los objetivos planteados."</p>
                <p>"Estamos <span class="highlight">muy satisfechos con el resultado</span> y con todo lo que hemos aprendido colaborando juntos en este proyecto."</p>
            </div>
             <div class="guion-item">
                <h3>Diapositiva 11 (Opcional): Posibles Mejoras Futuras</h3>
                <p><strong>Guion:</strong></p>
                <p>"Aunque estamos contentos con la versión actual, siempre hay espacio para <span class="keyword">evolucionar</span>. Algunas <span class="highlight">mejoras futuras</span> que podrían considerarse incluyen la adición de más tipos de enemigos con <span class="emphasis">comportamientos programados más complejos</span>, una mayor variedad de <span class="keyword">power-ups</span> con efectos más sorprendentes, la implementación de <span class="highlight">niveles de dificultad progresiva</span> más allá de los cambios visuales y de velocidad actuales, e incluso la incorporación de <span class="emphasis">jefes de nivel</span> para un desafío mayor. También se podrían explorar <span class="keyword">mejoras gráficas y sonoras</span> para una experiencia más inmersiva."</p>
            </div>
        </section>
    </div>

    <footer>
        <p>&copy; 2024 Equipo PAF803_3 - Juego de Asteroides. Todos los derechos reservados (para la presentación).</p>
    </footer>
</body>
</html> 